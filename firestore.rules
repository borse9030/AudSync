/**
 * @file Firestore Security Rules for AudSync
 * @version Prototyping
 *
 * @description This ruleset enforces a user-ownership model combined with role-based access control for collaborative room management.
 *   It prioritizes secure access to user data, room management, and synchronized audio playback. The rules are designed to be
 *   flexible for prototyping, focusing on authorization and relational integrity while deferring strict schema validation.
 *
 * @dataStructure
 *   - /users/{userId}: Stores user profiles.
 *   - /users/{userId}/rooms/{roomId}: Stores room details specific to each user.
 *   - /rooms/{roomId}: Stores general room information (e.g., host, playlist).
 *   - /rooms/{roomId}/devices/{deviceId}: Stores device presence information within a room.
 *   - /rooms/{roomId}/playlists/{playlistId}: Stores playlist data for a given room.
 *   - /tracks/{trackId}: Stores audio track metadata.
 *
 * @keySecurityDecisions
 *   - Strict User Ownership: Most data is secured using an ownership model based on the authenticated user's ID.
 *   - Host Role for Room Management: Room hosts have elevated privileges for managing room state and membership.
 *   - Denormalization for Authorization: `hostId` is denormalized into the User document to avoid costly `get()` calls in security rules.
 *   - Immutable Relationships: Once a user or device is associated with a room, that association cannot be changed.
 *   - No User Listing: Listing all users is disallowed to protect user privacy.
 *
 * @denormalizationForAuthorization
 *   - The `hostId` of a `Room` is denormalized into the `User` document to allow user-specific rules to quickly check if the user is the host of the room without requiring a `get()` operation on the `Room` document.
 *
 * @structuralSegregation
 *   - User-specific room data is stored in `/users/{userId}/rooms/{roomId}`, while general room data is stored in `/rooms/{roomId}`. This segregation allows for different access control rules for user-specific vs. general room information.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (create) Signed-in user creates their own profile.
     * @allow (get, update, delete) Signed-in user accesses/modifies their own profile.
     * @deny (create) Signed-in user tries to create another user's profile.
     * @deny (get, update, delete) Signed-in user tries to access/modify another user's profile.
     * @deny (list) Listing all users is not allowed.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == request.auth.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to room details specific to a user.
     * @path /users/{userId}/rooms/{roomId}
     * @allow (create) Signed-in user creates a room under their profile.
     * @allow (get, update, delete) Signed-in user accesses/modifies their own room.
     * @deny (create) Signed-in user tries to create a room under another user's profile.
     * @deny (get, update, delete) Signed-in user tries to access/modify another user's room.
     * @principle Enforces document ownership for writes, validating relational integrity.
     */
    match /users/{userId}/rooms/{roomId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to device presence information within a room.
     * @path /rooms/{roomId}/devices/{deviceId}
     * @allow (create, update) Signed-in device creates/updates its own presence.
     * @allow (get) Any signed-in user can view device presence.
     * @deny (create, update, delete) Signed-in device tries to create/update/delete another device's presence.
     * @principle Enforces device ownership for writes, allowing public read access.
     */
    match /rooms/{roomId}/devices/{deviceId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isDeviceOwner(deviceId) {
        return isSignedIn() && request.auth.uid == deviceId;
      }
       function isExistingDeviceOwner(deviceId) {
        return isDeviceOwner(deviceId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isDeviceOwner(deviceId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingDeviceOwner(deviceId) && request.resource.data.id == request.auth.uid;
      allow delete: if isExistingDeviceOwner(deviceId);
    }

    /**
     * @description Controls access to general room information.
     * @path /rooms/{roomId}
     * @allow (get, list) Any signed-in user can view room information.
     * @allow (create) Signed-in user can create room information.
     * @deny (update, delete) Only the host can update/delete room information.
     * @principle Restricts write access to the room host.
     */
    match /rooms/{roomId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isHost() {
          return isSignedIn() && request.auth.uid == resource.data.hostId;
      }
       function isExistingHost() {
        return isHost() && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingHost();
      allow delete: if isExistingHost();
    }

    /**
     * @description Controls access to playlist data for a given room.
     * @path /rooms/{roomId}/playlists/{playlistId}
     * @allow (get, list) Any signed-in user can view playlist data.
     * @allow (create, update, delete) Only the host can create/update/delete playlist data.
     * @principle Restricts write access to the room host.
     */
    match /rooms/{roomId}/playlists/{playlistId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isRoomHost(roomId) {
          return isSignedIn() && get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isRoomHost(roomId);
      allow update: if isSignedIn() && isRoomHost(roomId);
      allow delete: if isSignedIn() && isRoomHost(roomId);
    }

    /**
     * @description Controls access to audio track information.
     * @path /tracks/{trackId}
     * @allow (get, list) Any signed-in user can view track information.
     * @deny (create, update, delete) No one can create, update, or delete tracks via Firestore. Tracks are managed via separate process (e.g., Cloud Functions).
     * @principle Read-only access for track metadata.
     */
    match /tracks/{trackId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}