/**
 * @file Firestore Security Rules for AudSync
 * @version Prototyping Mode - Data shape is not strictly enforced.
 *
 * @Core Philosophy: This ruleset prioritizes authorization independence by denormalizing data
 *   and enforces a strict ownership model for user and room data. It leverages path-based
 *   authorization and authenticated user identity.
 *
 * @Data Structure:
 *   - /users/{userId}: Stores user profiles.
 *   - /users/{userId}/rooms/{roomId}: Stores room details specific to a user (for host access).
 *   - /rooms/{roomId}: Stores global room information.
 *   - /rooms/{roomId}/devices/{deviceId}: Stores device presence information within a room.
 *   - /rooms/{roomId}/playlists/{playlistId}: Stores playlist data for a room.
 *   - /tracks/{trackId}: Stores track information.
 *
 * @Key Security Decisions:
 *   - Users can only manage their own profile data.
 *   - Room hosts have control over room playback state and playlists.
 *   - Devices can only update their own presence information within a room.
 *   - Public listing of user documents is disallowed to prevent data leakage.
 *   - Data validation is limited to fields essential for authorization and relational integrity.
 *
 * @Denormalization for Authorization:
 *   - hostId from Room is denormalized into User to avoid get() calls for ownership checks.
 *   - roomId is denormalized into the User object.
 *
 * @Structural Segregation:
 *   - User-specific data is stored under /users/{userId} to simplify ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to manage their own profile data.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @deny (create) User tries to create a profile with a mismatched ID.
     * @principle Enforces user ownership for profile management.
     */
    match /users/{userId} {
      // Verifies the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Verifies that the request is made by the owner
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Verifies that the request is made by an existing owner
      function isExistingOwner(userId) {
        return isOwner(userId) && existsAfter(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId); // No immutability check during prototyping
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows the host to manage the room's playback state and settings.
     * @path /users/{userId}/rooms/{roomId}
     * @allow (create) Host creates a room under their user ID.
     * @deny (create) Non-host tries to create a room under another user's ID.
     * @principle Enforces host ownership for room management.
     */
    match /users/{userId}/rooms/{roomId} {
       // Verifies the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Verifies that the request is made by the owner
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Verifies that the request is made by an existing owner
      function isExistingOwner(userId) {
        return isOwner(userId) && existsAfter(/databases/$(database)/documents/users/$(userId)/rooms/$(roomId));
      }
      allow get: if isOwner(userId);
      allow list: if isOwner(userId); // Allows the owner to list their own rooms

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Allows devices to update their own presence information within a room.
      * @path /rooms/{roomId}/devices/{deviceId}
      * @allow (create, update) Device updates its own presence using its device ID.
      * @deny (create, update) Device tries to update another device's presence.
      */
    match /rooms/{roomId}/devices/{deviceId} {
       // Verifies the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Verifies that the request is made by the device
      function isDevice(deviceId) {
        return request.auth.token.firebase.sign_in_provider == "anonymous" && request.auth.uid == deviceId;
      }

      // Verifies that the request is made by an existing device
      function isExistingDevice(deviceId) {
        return isDevice(deviceId) && existsAfter(/databases/$(database)/documents/rooms/$(roomId)/devices/$(deviceId));
      }

      allow get: if isSignedIn(); // Added explicit allow rule for reading device data
      allow list: if isSignedIn();

      allow create: if isDevice(deviceId);
      allow update: if isExistingDevice(deviceId);
      allow delete: if false; // Devices cannot delete their presence.
    }

    /**
     * @description Allows authorized users to read room information.
     * @path /rooms/{roomId}
     * @allow (get, list) Any authenticated user can read room information.
     * @deny (create, update, delete) Only the host can modify room information.
     * @principle Restricts write access to room data to the host.
     */
    match /rooms/{roomId} {
       // Verifies the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

       // Verifies that the request is made by the owner
      function isOwner(roomId) {
        return get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid;
      }

      // Verifies that the request is made by an existing owner
      function isExistingOwner(roomId) {
        return isOwner(roomId) && existsAfter(/databases/$(database)/documents/rooms/$(roomId));
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();

      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if isExistingOwner(roomId); // Requires "hostId" field
      allow delete: if isExistingOwner(roomId); // Requires "hostId" field
    }

    /**
     * @description Allows the host to manage the room's playlist.
     * @path /rooms/{roomId}/playlists/{playlistId}
     * @allow (create, update, delete) Host can manage the playlist for their room.
     * @deny (create, update, delete) Non-host tries to modify the playlist.
     * @principle Enforces host ownership for playlist management.
     */
    match /rooms/{roomId}/playlists/{playlistId} {
        // Verifies the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Verifies that the request is made by the owner
       function isOwner(roomId) {
        return get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid;
      }

      // Verifies that the request is made by an existing owner
      function isExistingOwner(roomId) {
        return isOwner(roomId) && existsAfter(/databases/$(database)/documents/rooms/$(roomId)/playlists/$(playlistId));
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();

      allow create: if isOwner(roomId); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if isExistingOwner(roomId); // Requires "hostId" field
      allow delete: if isExistingOwner(roomId); // Requires "hostId" field
    }

    /**
     * @description Allows any authenticated user to read track information.
     * @path /tracks/{trackId}
     * @allow (get, list) Any authenticated user can read track information.
     * @deny (create, update, delete) Only authorized users (e.g., admins) can modify track information.
     * @principle Open read access for track data.
     */
    match /tracks/{trackId} {
       // Verifies the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();

      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}