/**
 * @fileoverview Firestore Security Rules for Auding, a real-time synchronized audio playback application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and room management, combined with device-level authorization for presence within rooms.
 * Authorization independence is achieved via denormalization of the `hostId` into the `User` document.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the user themselves.
 * - /users/{userId}/rooms/{roomId}: Stores user-specific room details, managed by the host.
 * - /rooms/{roomId}: Stores room metadata, writable only by the host.
 * - /rooms/{roomId}/devices/{deviceId}: Stores device presence data, writable only by the corresponding device.
 * - /rooms/{roomId}/playlists/{playlistId}: Stores playlist information specific to a room.
 * - /tracks/{trackId}: Stores global audio track metadata (assumed to be publicly readable, owner-writable).
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Only the room host can modify room metadata.
 * - Devices can only update their own presence information within a room.
 * - Tracks are globally readable but writable only by an owner (not yet implemented due to missing schema information).
 * - Listing of users is disallowed for privacy.
 *
 * Denormalization for Authorization:
 * - The `hostId` is denormalized from the `Room` document into the `User` document to avoid `get()` calls in security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profile information. Only the user can access their own profile.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile.
     * @allow (get, update, delete) Authenticated user 'user123' reads/updates/deletes their own profile.
     * @deny (create, get, update, delete) Authenticated user 'user456' attempts to access 'user123' profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user-specific room details. Accessible only to the room host.
     * @path /users/{userId}/rooms/{roomId}
     * @allow (create) Host 'user123' creates a room with ID 'room456' under their profile.
     * @allow (get, update, delete) Host 'user123' reads/updates/deletes room 'room456' under their profile.
     * @deny (create, get, update, delete) User 'user456' attempts to access room 'room456' under 'user123' profile.
     * @principle Restricts access to user-owned data trees.
     */
    match /users/{userId}/rooms/{roomId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure device presence information within a room. Devices can only manage their own presence.
     * @path /rooms/{roomId}/devices/{deviceId}
     * @allow (create, update, delete) Device 'device789' creates/updates/deletes its presence in room 'room456'.
     * @deny (create, update, delete) Device 'device012' attempts to manage 'device789' presence in room 'room456'.
     * @principle Enforces device-level ownership.
     */
    match /rooms/{roomId}/devices/{deviceId} {
      function isDevice(deviceId) {
        return request.auth != null && request.auth.token.device_id == deviceId;
      }
       function isExistingDevice(deviceId) {
        return isDevice(deviceId) && resource != null;
      }

      allow get: if request.auth != null;
      allow list: if true;
      allow create: if request.auth != null;
      allow update: if isExistingDevice(deviceId);
      allow delete: if isExistingDevice(deviceId);
    }

    /**
     * @description Secure room metadata. Only the room host can modify it.
     * @path /rooms/{roomId}
     * @allow (create, update, delete) Host 'user123' creates/updates/deletes room 'room456'.
     * @deny (create, update, delete) User 'user456' attempts to manage room 'room456'.
     * @principle Enforces host-level ownership for room management.
     */
    match /rooms/{roomId} {
      function isHost(roomId) {
        return request.auth != null && get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid;
      }
        function isExistingHost(roomId) {
        return isHost(roomId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if request.auth != null;
      allow update: if isExistingHost(roomId);
      allow delete: if isExistingHost(roomId);
    }

    /**
     * @description Secure playlist data for a room. Access is restricted to the room.
     * @path /rooms/{roomId}/playlists/{playlistId}
     */
    match /rooms/{roomId}/playlists/{playlistId} {
      function isHost(roomId) {
        return request.auth != null && get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid;
      }
      function isExistingHost(roomId) {
        return isHost(roomId) && resource != null;
      }

      allow get: if isHost(roomId);
      allow list: if isHost(roomId);
      allow create: if isHost(roomId);
      allow update: if isExistingHost(roomId);
      allow delete: if isExistingHost(roomId);
    }

    /**
     * @description Secure audio track information.
     * @path /tracks/{trackId}
     */
    match /tracks/{trackId} {
      // CRITICAL: Cannot implement owner-only writes. The 'Track' entity is missing an 'ownerId' or 'authorId' field.
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}