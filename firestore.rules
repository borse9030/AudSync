/**
 * @file Firestore Security Rules for AudSync
 * @version Prototyping
 *
 * @description This ruleset enforces a device-ownership model for device presence,
 *              a host-ownership model for room playback control, and allows public read
 *              access to track data. It uses denormalization of `hostId` into the `User`
 *              document for authorization independence and assumes `deviceId` matches `auth.uid` for anonymous users.
 *
 * @dataStructure
 *  - /users/{userId}: User profile data, including denormalized room and host information.
 *  - /users/{userId}/rooms/{roomId}: Room details specific to a user.
 *  - /rooms/{roomId}/devices/{deviceId}: Device presence information within a room.
 *  - /rooms/{roomId}: Room metadata, including playback state and host information.
 *  - /rooms/{roomId}/playlists/{playlistId}: Playlists associated with a room.
 *  - /tracks/{trackId}: Audio track metadata.
 *
 * @keySecurityDecisions
 *  - Users can only modify their own user documents.
 *  - Devices can only manage their own presence records within a room.
 *  - Only the room host can control playback.
 *  - Track data is publicly readable.
 *  - Listing of users and playlists is not explicitly allowed.
 *
 * @denormalizationForAuthorization
 *  - The `hostId` is denormalized from the `Room` document into the `User` document
 *    to avoid `get()` operations in security rules when validating user-specific actions.
 *
 * @structuralSegregation
 *  - User-owned data is stored under /users/{userId} to simplify security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @allow (get, update, delete) User with matching ID can read, update, and delete their profile.
     * @deny (create) User cannot create a profile with a mismatched ID.
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      //function isOwner(userId) {
      //  return request.auth.uid == userId;
      //}
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to room details specific to a user.
     * @path /users/{userId}/rooms/{roomId}
     * @allow (create, get, update, delete) User with matching ID can manage their own rooms.
     * @deny (create) User cannot create a room with a mismatched ID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/rooms/{roomId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to device presence information within a room.
     * @path /rooms/{roomId}/devices/{deviceId}
     * @allow (create, get, update, delete) Device with matching ID can manage their own presence.
     * @deny (create) Device cannot create a presence record with a mismatched ID.
     * @principle Enforces device ownership for writes.
     */
    match /rooms/{roomId}/devices/{deviceId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == deviceId && request.resource.data.id == deviceId;
      allow update: if isSignedIn() && request.auth.uid == deviceId && resource != null && request.resource.data.id == deviceId;
      allow delete: if isSignedIn() && request.auth.uid == deviceId && resource != null;
    }

    /**
     * @description Controls access to room metadata.
     * @path /rooms/{roomId}
     * @allow (get) Anyone can read room metadata.
     * @allow (create, update, delete) Only the host can create, update, and delete room metadata.
     * @principle Enforces host-ownership for room management.
     */
    match /rooms/{roomId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && request.resource.data.hostId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && request.resource.data.hostId == request.auth.uid;
    }

    /**
     * @description Controls access to playlists associated with a room.
     * @path /rooms/{roomId}/playlists/{playlistId}
     * @allow (get) Anyone can read the playlist.
     * @allow (create, update, delete) Only the host can create, update, and delete playlists.
     * @principle Enforces host-ownership for playlist management.
     */
    match /rooms/{roomId}/playlists/{playlistId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/rooms/$(roomId)).data.hostId == request.auth.uid && resource != null;
    }

    /**
     * @description Controls access to audio track metadata.
     * @path /tracks/{trackId}
     * @allow (get, list) Anyone can read track metadata.
     * // CRITICAL: Cannot implement owner-only writes. The 'Track' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /tracks/{trackId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    // functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}