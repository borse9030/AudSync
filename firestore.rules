/**
 * @fileoverview Firestore Security Rules for AudSync.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership and role-based access control model,
 * ensuring that users can only manage their own data and that room hosts have
 * control over room settings and playback.  Authorization Independence is achieved
 * via denormalization of hostId into User documents and adding room ID as metadata
 * on audio files to avoid get() calls in rules.  Structural Segregation is used to
 * separate user-owned data (under /users/{userId}) from room-specific data
 * (under /rooms/{roomId}).
 *
 * Data Structure:
 * - /users/{userId}: User profile information.
 * - /users/{userId}/rooms/{roomId}: User-specific room details.
 * - /rooms/{roomId}: Room metadata and settings.
 * - /rooms/{roomId}/devices/{deviceId}: Device presence within a room.
 * - /rooms/{roomId}/playlists/{playlistId}: Playlists associated with a room.
 * - /tracks/{trackId}: Audio track metadata.
 *
 * Key Security Decisions:
 * - Users can only manage their own profile data.
 * - Room hosts (identified by hostId) have write access to room metadata.
 * - Devices can only manage their own presence within a room.
 * - Listing of users is generally disallowed for privacy.
 * - Denormalization is employed to avoid costly `get()` operations within rules.
 * - The rules are structured to easily accommodate future roles (e.g., admin).
 *
 * Denormalization for Authorization:
 * - User documents denormalize 'roomId' and 'hostId' from the Room for authorization independence.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure access to user profile information.
     * @path /users/{userId}
     * @allow (create) User 'user_abc' can create their profile if request.auth.uid == 'user_abc'.
     * @deny (create) User 'user_xyz' cannot create a profile with ID 'user_abc'.
     * @allow (get) User 'user_abc' can read their own profile.
     * @deny (get) User 'user_xyz' cannot read user 'user_abc' profile.
     * @allow (update) User 'user_abc' can update their own profile.
     * @deny (update) User 'user_xyz' cannot update user 'user_abc' profile.
     * @allow (delete) User 'user_abc' can delete their own profile.
     * @deny (delete) User 'user_xyz' cannot delete user 'user_abc' profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the authenticated user is the owner of the resource.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the authenticated user is the owner of the resource, and that the document exists
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if true;
      allow list: if false;

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to user-specific room details.
     * @path /users/{userId}/rooms/{roomId}
     * @allow (create) User 'user_abc' can create a room with ID 'room_123' under their profile.
     * @deny (create) User 'user_xyz' cannot create a room under user 'user_abc' profile.
     * @allow (get) User 'user_abc' can read room 'room_123' details under their profile.
     * @deny (get) User 'user_xyz' cannot read rooms under user 'user_abc' profile.
     * @allow (update) User 'user_abc' can update room 'room_123' details under their profile.
     * @deny (update) User 'user_xyz' cannot update rooms under user 'user_abc' profile.
     * @allow (delete) User 'user_abc' can delete room 'room_123' details under their profile.
     * @deny (delete) User 'user_xyz' cannot delete rooms under user 'user_abc' profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/rooms/{roomId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the authenticated user is the owner of the resource.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the authenticated user is the owner of the resource, and that the document exists
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to device presence information within a room.
     * @path /rooms/{roomId}/devices/{deviceId}
     * @allow (create) Device 'device_xyz' can create its presence record in room 'room_123'.
     * @deny (create) Device 'device_abc' cannot create presence record for 'device_xyz'.
     * @allow (get) Any signed-in user can get device presence information.
     * @deny (get) N/A
     * @allow (update) Device 'device_xyz' can update its own presence record.
     * @deny (update) Device 'device_abc' cannot update presence record for 'device_xyz'.
     * @allow (delete) Device 'device_xyz' can delete its own presence record.
     * @deny (delete) Device 'device_abc' cannot delete presence record for 'device_xyz'.
     * @principle Enforces device-level ownership for presence updates.
     */
    match /rooms/{roomId}/devices/{deviceId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the device ID matches the authenticated user's UID.
      function isDeviceOwner(deviceId) {
        return request.auth.uid == deviceId;
      }

      // Helper function to check if the device is the owner, and the document exists
      function isExistingDeviceOwner(deviceId) {
          return isDeviceOwner(deviceId) && resource != null;
      }

      allow get: if true;
      allow list: if true; // Allowing all users to list devices in a room.

      allow create: if isSignedIn() && isDeviceOwner(deviceId);
      allow update: if isExistingDeviceOwner(deviceId);
      allow delete: if isExistingDeviceOwner(deviceId);
    }

    /**
     * @description Secure access to room metadata and settings.
     * @path /rooms/{roomId}
     * @allow (create) User 'user_abc' can create a room.
     * @deny (create) User 'user_xyz' cannot create a room.
     * @allow (get) Anyone can read room information.
     * @deny (get) N/A
     * @allow (update) Only the host ('user_abc') can update room settings.
     * @deny (update) User 'user_xyz' cannot update room settings.
     * @allow (delete) Only the host ('user_abc') can delete the room.
     * @deny (delete) User 'user_xyz' cannot delete the room.
     * @principle Restricts write access to the room host.
     */
    match /rooms/{roomId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the authenticated user is the room host.
      function isHost(hostId) {
        return request.auth.uid == hostId;
      }

      // Helper function to check if the user is the host, and the document exists
      function isExistingHost(hostId) {
          return isHost(hostId) && resource != null;
      }

      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn(); // Anybody signed in can create a room
      allow update: if isExistingHost(resource.data.hostId);
      allow delete: if isExistingHost(resource.data.hostId);
    }

    /**
     * @description Secure access to playlists associated with a room.
     * @path /rooms/{roomId}/playlists/{playlistId}
     * @allow (create) Host 'user_abc' can create a playlist for room 'room_123'.
     * @deny (create) User 'user_xyz' cannot create playlists for room 'room_123'.
     * @allow (get) Anyone can read playlist information.
     * @deny (get) N/A
     * @allow (update) Host 'user_abc' can update a playlist for room 'room_123'.
     * @deny (update) User 'user_xyz' cannot update playlists for room 'room_123'.
     * @allow (delete) Host 'user_abc' can delete a playlist for room 'room_123'.
     * @deny (delete) User 'user_xyz' cannot delete playlists for room 'room_123'.
     * @principle Restricts write access to the room host.
     */
    match /rooms/{roomId}/playlists/{playlistId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the authenticated user is the room host.
      function isHost(hostId) {
        return request.auth.uid == hostId;
      }

      // Helper function to check if the user is the host, and the document exists
      function isExistingHost(hostId) {
          return isHost(hostId) && resource != null;
      }

      allow get: if true;
      allow list: if true; // Anyone can list the playlists of a given room

      allow create: if isSignedIn(); // Anybody signed in can create a playlist
      allow update: if isExistingHost(resource.data.hostId);
      allow delete: if isExistingHost(resource.data.hostId);
    }

    /**
     * @description Secure access to audio track metadata.
     * @path /tracks/{trackId}
     * @allow (get) Anyone can read track metadata.
     * @deny (get) N/A
     * @allow (list) Anyone can list tracks.
     * @deny (list) N/A
     * @allow (create) if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow (update) if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow (delete) if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Requires owner-only writes, but currently lacks the required schema field.
     */
    match /tracks/{trackId} {
        // CRITICAL: Cannot implement owner-only writes. The 'Track' entity is missing an 'ownerId' or 'authorId' field.

        allow get, list: if true;

        allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}